; CMHG template, generated by CMunge 0.77 (13 Jun 2006)
;
; Customise this to fit the module you are writing

#include "VersionNum"
#include "riscos/Services.h"

; If you declare module-is-runnable the module will be entered at the main()
; function in user mode (ie like a normal C program).
; You will probably never need this field.
;module-is-runnable: 

; When your module cannot be reentered you should declare this. At present
; it does nothing.
; You will probably never need this field.
;module-is-not-reentrant: 

; When your module includes C++ code built using the CFront compiler, you
; should declare this. As part of the module initialisation sequence, the
; C++ global constructors will be called. Essentially this removes the
; requirement to manually invoke ______main.
;module-is-c-plus-plus: 

; You should give your module a sensible name which describes its purpose
; both accurately and concisely. You must register any module names you use
; if they are to be distributed.
title-string: VNCResize

; The help-string is the name that is displayed to the user in *Help Modules
; and other places that a more readable name is required. You should attempt
; to make this a readable version of the title-string, and - at worst - use
; the same name as in the title-string. The tail message may be used to
; indicate a variant of the module, or a copyright string.
help-string: VNCResize Module_MajorVersion_CMHG

; If you supply SWIs in your module, you must provide a base number at which
; these start. Each chunk is 64 entries long and must be registered if the
; module is going to be distributed.
; SWI chunks &0- &3FFC0 are for operating system use.
; &40000- &7FFC0 are for operating system exetensions.
; &80000- &BFFC0 are for third-party applications.
; &C0000- &FFFC0 are for user applications.
; Bit 17 will always be clear on the SWI chunk number.
; Consult PRM 1-26 for more details.
;swi-chunk-base-number: &C0000

; If you have any error messages in your module that are returned through
; the standard interfaces, you should use different error numbers for each,
; starting at a base number. You should register your error bases before
; distributing the module. Using random error numbers is dangerous.
; Error chunks &0- &7FFFFF are for operating system use.
; &800000- &FFFFFF are for other authors.
; &1B000000- &1BFFFFFF are for program (NOT module) errors.
; &80000000- &FFFFFFFF are for serious hardware exceptions.
; Consult PRM 1-43, 5a-493 for more details.
;error-base: &840000

; Allocating error messages within the module is more efficient than doing
; so manually in your C code, and is less likely to pollute error number
; space. The number is optional, and if omitted will be allocated from the
; error chunk.
;error-identifiers: err_Silly(&1234,"Silly")

; When the module is initialised, this routine will be entered. You should
; be very careful to initialise your module safely. If anything fails, you
; can return an error message. Finalisation code will not be called if you
; return an error.
initialisation-code: Mod_Init

; When the module is killed, this routine will be entered. If you do not
; wish to be killed then you should return an error and retain as much of
; the current state as possible. Causing an abort in this routine will leave
; a 'dead' module in the chain.
finalisation-code: Mod_Final

; Syntax and help messages may be internationalised by using a messages
; file.
;international-help-file: "Resources:$.ThirdParty.VNCResize.Messages"

; The SWI handler is entered for every SWI the module provides. Generally,
; this is a switch statement, to dispatch each of the SWIs that are known.
;swi-handler-code: Mod_SWI

; The SWI decoding code performs name-to-number and number-to-name
; translations for this module. In practice, you very rarely need to use
; this.
; You will probably never need this field.
;swi-decoding-code: Mod_SWIDecoder

; The SWI decoding table lists the SWIs which the module supplies. The first
; entry is always the SWI prefix, used on all SWIs that the module provides.
; This should be the name of the module, or some obvious variant. You should
; register your SWI prefixes when you register a SWI chunk. Each name entry
; may be followed by /<entry> to use a particular routine to handle a SWI.
;swi-decoding-table: VNCResize One Two Three

; The library initialisation code sets up the C environment for use with
; this module. You may wish to perform some initialisation prior to the C
; environment being created. You must call _clib_initialisemodule prior to
; returning, or provide an identical functionality.
; You will probably never need this field.
;library-enter-code: _clib_initialisemodule

; The date-string is optional and should only be included if you feel that a
; date is a different reference to the version number. Certain ports from
; other platforms may wish to indicate their source base date using this
; field.
; You will probably never need this field.
;date-string: 21 Dec 1999

; Generic veneers are used to provide a simple C environment for SVC and IRQ
; modes. You should register the Entry routine as the external interface (ie
; provide it as the code address to call). The Handler routine will be
; called from this. Parameters for the veneer may be specified in brackets
; in the same form as command keywords :
;   ({<field>: <value>})
; Field names:
;   private-word: <register> Private word register
;   carry-capable:           Veneer is capable of handling returning of the
;                            carry flag
generic-veneers: ModeChanged_Entry/ModeChanged_Handler

; IRQ veneers are the old name for vector-handlers. Use vector-handlers in
; preference to irq-handlers.
;irq-handlers: IRQ_Entry/IRQ_Handler

; Vector veneers are used to provide a simple C environment for SVC and IRQ
; modes. You should register the Entry routine as the external interface (ie
; provide it as the code address to call). The Handler routine will be
; called from this. You can return 0 or 1 from your routine to say you
; either handled the vector, or did not. Parameters for the veneer may be
; specified in brackets in the same form as command keywords :
;   ({<field>: <value>})
; Field names:
;   error-capable: Veneer is capable of claiming the vector and returning an
;                  error
;vector-handlers: Vector_Entry/Vector_Handler

; VectorTrap veneers are used to provide a simple C environment for SVC and
; IRQ modes. You should register the Entry routine as the external interface
; (ie provide it as the code address to call). The Handler routine will be
; called from this. You can an error to pass this back to the calling. The
; function 'trap' can be called with a register block and private value to
; pass the call on to the vector. The trap function will return registers in
; the supplied block, and if an error is flagged this will be the return
; value.
;vector-traps: VectorTrap_Entry/VectorTrap_Handler

; Event handlers are used to provide a simple C environment for SVC and IRQ
; modes. You should register the Entry routine as the external interface (ie
; provide it as the code address to call). The Handler routine will be
; called from this. You can return 0 or 1 from your routine to say you
; either handled the interrupt, or did not. The list of numbers at the end
; of the line indicates which events (in R0) will be passed to the Handler
; routine. You can also trap upcalls with an event handler, as their reason
; codes are also passed in R0.
;event-handler: Event_Entry/Event_Handler 1 2 3 4 5 6

; The command table is one of the more complex fields in the CMHG file. The
; first entry is the routine to call to process the commands as they arrive.
; The remainder of the entries are the command definitions. These take the
; form :
;   <Command>({<field>: <value>})
;
; Field names:
;   min-args: <number>
;     Minimum number of arguments acceptable for this command.
;   max-args: <number>
;     Maximum number of arguments acceptable for this command.
;   gstrans-map: <bits>
;     A bit-field describing which arguments to the command will be
;     processed by GSTrans before being passed to the module.
;   fs-command:
;     This command is a filing system specific command. It will only be used
;     if the current filing system is this module.
;   international:
;     The help text for this command should be translated through the
;     messages file supplied in the 'international-help-file' field.
;   add-syntax:
;     The text supplied in the 'invalid-syntax' field will be appended to
;     the text supplied in the 'help-text' field.
;   configure:
;     The command is used for *Status and *Configure commands only. This is
;     equivalent to the 'status' field.
;   status:
;     The command is used for *Status and *Configure commands only. This is
;     equivalent to the 'configure' field.
;   help:
;     The command handler will be called to process help requests.
;   invalid-syntax: <string>
;     When an invalid syntax has been supplied, the supplied text will be
;     displayed. If the 'add-syntax' field is used, the text will be
;     appended to the content of the 'help-text' field. If the
;     'international' field is set, the string supplied is a token to be
;     looked up in the messages file.
;   help-text: <string>
;     When an invalid syntax has been supplied, the supplied text will be
;     displayed. If the 'add-syntax' field is used, the text will be
;     appended to the content of the 'help-text' field. If the
;     'international' field is set, the string supplied is a token to be
;     looked up in the messages file.
;   handler: <function>
;     The function to call to handle this command. Setting this field
;     overrides the use of default handler function.
;   no-handler:
;     The command has no handler function present. This is useful for
;     creating help-only commands.
;command-keyword-table: Mod_Command
;   ModuleCommand()

; The module service entry will be called to process services. You are
; strongly recommended to include the numbers of the services you wish to
; handle.
service-call-handler: Mod_Service Service_ModeChange

